commit cebe33766bd1d672618a2931ceb50ae64fb994ed
Author: Ludger Kr√§mer <dbluelle@onlinehome.de>
Date:   Sat Sep 1 13:17:34 2018 +0200

    use libswresample instead of libavresample, if available

diff --git a/CMakeLists.txt b/CMakeLists.txt
index c195aa14..b76e228f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -291,6 +291,7 @@ ENDIF(WIN32)
 
 IF(ENABLE_LIBAVCODEC)
 	pkg_check_modules(FFMPEG libavcodec libavutil libavformat)
+	pkg_check_modules(LIBSWRESAMPLE libswresample)
 	pkg_check_modules(LIBAVRESAMPLE libavresample)
 	IF(NOT(FFMPEG_FOUND))
 		INCLUDE(FindFFMpeg REQUIRED)
@@ -298,9 +299,16 @@ IF(ENABLE_LIBAVCODEC)
 	# Compatibility checks for ffmpeg deprecated functions
   INCLUDE(CheckFunctionExists REQUIRED)
   INCLUDE(CheckCSourceCompiles)
-  SET(FFMPEG_FLAGS "${LIBAVCODEC_CFLAGS} ${LIBAVRESAMPLE_FLAGS}")
-  SET(FFMPEG_INCLUDE_DIRS "${FFMPEG_INCLUDE_DIRS};${LIBAVRESAMPLE_INCLUDE_DIRS}")
-  SET(FFMPEG_LIBRARIES "${FFMPEG_LIBRARIES};${LIBAVRESAMPLE_LIBRARIES}")
+  IF(LIBSWRESAMPLE_FOUND)
+    SET(FFMPEG_FLAGS "${LIBAVCODEC_CFLAGS} ${LIBSWRESAMPLE_FLAGS}")
+    SET(FFMPEG_INCLUDE_DIRS "${FFMPEG_INCLUDE_DIRS};${LIBSWRESAMPLE_INCLUDE_DIRS}")
+    SET(FFMPEG_LIBRARIES "${FFMPEG_LIBRARIES};${LIBSWRESAMPLE_LIBRARIES}")
+  ELSE()
+    # libavresample is deprecated, so only use it as a fallback for older ffmpeg
+    SET(FFMPEG_FLAGS "${LIBAVCODEC_CFLAGS} ${LIBAVRESAMPLE_FLAGS}")
+    SET(FFMPEG_INCLUDE_DIRS "${FFMPEG_INCLUDE_DIRS};${LIBAVRESAMPLE_INCLUDE_DIRS}")
+    SET(FFMPEG_LIBRARIES "${FFMPEG_LIBRARIES};${LIBAVRESAMPLE_LIBRARIES}")
+  ENDIF(LIBSWRESAMPLE_FOUND)
   SET(CMAKE_REQUIRED_FLAGS ${FFMPEG_FLAGS})
   SET(CMAKE_REQUIRED_INCLUDES ${FFMPEG_INCLUDE_DIRS})
   SET(CMAKE_REQUIRED_LIBRARIES ${FFMPEG_LIBRARIES})
@@ -351,9 +359,14 @@ IF(ENABLE_LIBAVCODEC)
   IF(HAVE_AVCODECID)
     ADD_DEFINITIONS(-DHAVE_AVCODECID)
   ENDIF(HAVE_AVCODECID)
-  IF(LIBAVRESAMPLE_FOUND)
-    ADD_DEFINITIONS(-DHAVE_LIBAVRESAMPLE)
-  ENDIF(LIBAVRESAMPLE_FOUND)
+  IF(LIBSWRESAMPLE_FOUND)
+    ADD_DEFINITIONS(-DHAVE_LIBSWRESAMPLE)
+  ELSE()
+    # libavresample is deprecated, so only use it as a fallback for older ffmpeg
+    IF(LIBAVRESAMPLE_FOUND)
+      ADD_DEFINITIONS(-DHAVE_LIBAVRESAMPLE)
+    ENDIF(LIBAVRESAMPLE_FOUND)
+  ENDIF(LIBSWRESAMPLE_FOUND)
   IF(HAVE_AV_FRAME_ALLOC)
     ADD_DEFINITIONS(-DHAVE_AV_FRAME_ALLOC)
   ENDIF(HAVE_AV_FRAME_ALLOC)
diff --git a/ChangeLog b/ChangeLog
index e5a6f242..a8b24a6c 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,12 @@
 lightspark: An open source flash player implementation
 
+Version NEXT:
+
+	* use libswresample instead of libavresample, if available
+	* reduce memory usage
+	* several performance improvements
+	* add partial support for rtmfp protocol
+
 Version 0.8.1:
 
 	* make plugins work with newer versions of firefox and chromium
diff --git a/src/backends/decoder.cpp b/src/backends/decoder.cpp
index d1290cbd..e567c041 100755
--- a/src/backends/decoder.cpp
+++ b/src/backends/decoder.cpp
@@ -572,7 +572,7 @@ void AudioDecoder::skipAll()
 
 #ifdef ENABLE_LIBAVCODEC
 FFMpegAudioDecoder::FFMpegAudioDecoder(EngineData* eng,LS_AUDIO_CODEC audioCodec, uint8_t* initdata, uint32_t datalen):engine(eng),ownedContext(true)
-#ifdef HAVE_LIBAVRESAMPLE
+  #if defined HAVE_LIBAVRESAMPLE || defined HAVE_LIBSWRESAMPLE
 	,resamplecontext(NULL)
 #endif
 {
@@ -585,7 +585,10 @@ void FFMpegAudioDecoder::switchCodec(LS_AUDIO_CODEC audioCodec, uint8_t* initdat
 {
 	if (codecContext)
 		avcodec_close(codecContext);
-#ifdef HAVE_LIBAVRESAMPLE
+#ifdef HAVE_LIBSWRESAMPLE
+	if (resamplecontext)
+		swr_free(&resamplecontext);
+#elif defined HAVE_LIBAVRESAMPLE
 	if (resamplecontext)
 		avresample_free(&resamplecontext);
 #endif
@@ -618,7 +621,7 @@ void FFMpegAudioDecoder::switchCodec(LS_AUDIO_CODEC audioCodec, uint8_t* initdat
 }
 
 FFMpegAudioDecoder::FFMpegAudioDecoder(EngineData* eng,LS_AUDIO_CODEC lscodec, int sampleRate, int channels, bool):engine(eng),ownedContext(true)
-#ifdef HAVE_LIBAVRESAMPLE
+#if defined HAVE_LIBAVRESAMPLE || defined HAVE_LIBSWRESAMPLE
 	,resamplecontext(NULL)
 #endif
 {
@@ -652,7 +655,7 @@ FFMpegAudioDecoder::FFMpegAudioDecoder(EngineData* eng,LS_AUDIO_CODEC lscodec, i
 
 #if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(57, 40, 101)
 FFMpegAudioDecoder::FFMpegAudioDecoder(EngineData* eng,AVCodecParameters* codecPar):engine(eng),ownedContext(true),codecContext(NULL)
-#ifdef HAVE_LIBAVRESAMPLE
+#if defined HAVE_LIBAVRESAMPLE || defined HAVE_LIBSWRESAMPLE
 	,resamplecontext(NULL)
 #endif
 {
@@ -681,7 +684,7 @@ FFMpegAudioDecoder::FFMpegAudioDecoder(EngineData* eng,AVCodecParameters* codecP
 }
 #else
 FFMpegAudioDecoder::FFMpegAudioDecoder(EngineData* eng,AVCodecContext* _c):engine(eng),ownedContext(false),codecContext(_c)
-#ifdef HAVE_LIBAVRESAMPLE
+#if defined HAVE_LIBAVRESAMPLE || defined HAVE_LIBSWRESAMPLE
 	,resamplecontext(NULL)
 #endif
 {
@@ -712,7 +715,10 @@ FFMpegAudioDecoder::~FFMpegAudioDecoder()
 #if HAVE_AVCODEC_DECODE_AUDIO4
 	av_free(frameIn);
 #endif
-#ifdef HAVE_LIBAVRESAMPLE
+#ifdef HAVE_LIBSWRESAMPLE
+	if (resamplecontext)
+		swr_free(&resamplecontext);
+#elif defined HAVE_LIBAVRESAMPLE
 	if (resamplecontext)
 		avresample_free(&resamplecontext);
 #endif
@@ -990,7 +996,35 @@ int FFMpegAudioDecoder::resampleFrameToS16(FrameSamples& curTail)
 		return frameIn->linesize[0];
 	}
 	int maxLen;
-#ifdef HAVE_LIBAVRESAMPLE
+#ifdef HAVE_LIBSWRESAMPLE
+	if (!resamplecontext)
+		resamplecontext = swr_alloc();
+	av_opt_set_int(resamplecontext, "in_channel_layout",  frameIn->channel_layout, 0);
+	av_opt_set_int(resamplecontext, "out_channel_layout", channel_layout,  0);
+	av_opt_set_int(resamplecontext, "in_sample_rate",     framesamplerate,     0);
+	av_opt_set_int(resamplecontext, "out_sample_rate",    sample_rate,     0);
+	av_opt_set_int(resamplecontext, "in_sample_fmt",      frameIn->format,   0);
+	av_opt_set_int(resamplecontext, "out_sample_fmt",     AV_SAMPLE_FMT_S16,    0);
+	swr_init(resamplecontext);
+
+	
+	uint8_t *output;
+	int out_samples = av_rescale_rnd(swr_get_delay(resamplecontext, framesamplerate) + frameIn->nb_samples, sample_rate, sample_rate, AV_ROUND_UP);
+	int res = av_samples_alloc(&output, NULL, 2, out_samples,AV_SAMPLE_FMT_S16, 0);
+
+	if (res >= 0)
+	{
+		maxLen = swr_convert(resamplecontext, &output, out_samples, (const uint8_t**)frameIn->extended_data, frameIn->nb_samples)*2*av_get_channel_layout_nb_channels(channel_layout);// 2 bytes in AV_SAMPLE_FMT_S16
+		memcpy(curTail.samples, output, maxLen);
+		av_freep(&output);
+	}
+	else
+	{
+		LOG(LOG_ERROR, "resampling failed, error code:"<<res);
+		memset(curTail.samples, 0, frameIn->linesize[0]);
+		maxLen = frameIn->linesize[0];
+	}
+#elif defined HAVE_LIBAVRESAMPLE
 	if (!resamplecontext)
 	{
 		resamplecontext = avresample_alloc_context();
@@ -1020,7 +1054,7 @@ int FFMpegAudioDecoder::resampleFrameToS16(FrameSamples& curTail)
 		maxLen = frameIn->linesize[0];
 	}
 #else
-	LOG(LOG_ERROR, "unexpected sample format and can't resample, recompile with libavresample");
+	LOG(LOG_ERROR, "unexpected sample format and can't resample, recompile with libswresample");
 	memset(curTail.samples, 0, frameIn->linesize[0]);
 	maxLen = frameIn->linesize[0];
 #endif
diff --git a/src/backends/decoder.h b/src/backends/decoder.h
index 701a725b..b09800ce 100644
--- a/src/backends/decoder.h
+++ b/src/backends/decoder.h
@@ -28,7 +28,9 @@ extern "C"
 {
 #include <libavcodec/avcodec.h>
 #include <libavformat/avformat.h>
-#ifdef HAVE_LIBAVRESAMPLE
+#ifdef HAVE_LIBSWRESAMPLE
+#include <libswresample/swresample.h>
+#elif defined HAVE_LIBAVRESAMPLE
 #include <libavresample/avresample.h>
 #endif
 #include <libavutil/opt.h>
@@ -319,7 +321,9 @@ private:
 	EngineData* engine;
 	bool ownedContext;
 	AVCodecContext* codecContext;
-#ifdef HAVE_LIBAVRESAMPLE
+#ifdef HAVE_LIBSWRESAMPLE
+	SwrContext* resamplecontext;
+#elif defined HAVE_LIBAVRESAMPLE
 	AVAudioResampleContext* resamplecontext;
 #endif
 	std::vector<uint8_t> overflowBuffer;
diff --git a/src/platforms/engineutils.cpp b/src/platforms/engineutils.cpp
index b24d3167..0509d11d 100644
--- a/src/platforms/engineutils.cpp
+++ b/src/platforms/engineutils.cpp
@@ -923,7 +923,7 @@ void mixer_effect_ffmpeg_cb(int chan, void * stream, int len, void * udata)
 	AudioStream *s = (AudioStream*)udata;
 	if (!s)
 		return;
-
+	memset(stream,0,len);
 	uint32_t readcount = 0;
 	while (readcount < ((uint32_t)len))
 	{
